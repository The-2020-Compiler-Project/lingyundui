# 第二次过程报告
## 当前进度
目前我们小组成员都已经完成了各自负责的模块，下一步将配合组长完成最后的整合与调试工作，我负责的是中间代码的优化部分，目前已经可以实现预想中的功能，等待与其它成员负责的部分对接。
## 主要算法
程序主要是在基本块内的dag优化，将dag结点分为3类，如下所示：
+ 0型节点 （=，B， ，A）
+ 1型节点 （op，B， ，A）
+ 2型节点 （op，B，C，A）

优化方式主要有：
1. 删除公共子表达式
2. 用常数替换变量
3. 删除无用代码

在DAG图中，通过节点间的连线和层次关系来表示表示式或运算的归属关系：
+ 叶结点，即无后继的结点，以一标识符（变量名）或常数作为标记，表示这个结点代表该变量或常数的值。如果叶结点用来代表某变量A的地址，则用node（A）作为这个结点的标记。
+ 中间结点，即有后继的结点,以一运算符作为标记，表示这个结点代表应用该运算符对其后继结点所代表的值进行运算的结果。

DAG图的构建流程如下：

如果node(B)无定义，则构造一标记为B的叶结点并定义node(B)为这个结点如果当前四元式是0型，则记node(B)的值为n;,转1如果当前四元式是1型，则转2.(1);如果当前四元式是2型，则如果node(C)无定义，则构造一标记为C的叶结点并定义node(C)为这个结点,转3.(1)

1. 如果node(A)无定义,则把A附加在结点n上并令node(A)=n;否则先把A从node(A)结点上的附加标识符集中删除(如果node(A)是叶结点，则其标记A不删除),把A附加到新结点n上并令node(A)=n,结束，处理下一四元式

2.(1)如果Node(B)是标记为常数的叶结点,转2.(2),否则转2.(3)

2.(2)执行op B,令新得到的常量为P,如果node(B)是处理当前四元式时新构造出来的结点则删除它。如果node(P)无定义，则构造一用P做标记的叶结点n=node(P)，转1

2.(3)检查DAG中是否已有一结点，其唯一后继为node(B)，且标记为op(即公共表达式)。如果没有，则构造该结点n,否则将已有结点设为n,转1

3.(1)如果Node（B)和node(C)都是标记为常数的叶结点，则转3.(2),否则转3.(3)

3.（2）执行B op C,令新得到的常数为P，如果node(B)或node(C)是处理当前四元式时新构造出来的结点，则删除它。如果node(P)无定义，则构造一用P做标记的叶结点n,设Node(P)=n，转1

3.（3）检查DAG中是否已有一结点，其左后继为node(B),右后继为node(C)，且标记为op。如果没有，则构造该结点n,否则就把已有的结点作为它的结点并设该结点为n，转1

## 总结
这次尝试完成基于dag算法的中间代码优化对我来说也是一次难度不小的挑战，首先是早期设计的几种方法都很不理想，后来我又参考了很多资料以及和小组成员的探讨才完善到现在的版本，当然即使是现在这个算法也仍存在着不足，比如代码冗余，可维护性不强，没能完成预想中的循环优化等，另外我们也尝试过进一步完成后端的设计，但由于时间问题也只能放弃。虽然结果还是留下了一些遗憾，但在这次课程设计过程中我也学到了很多东西，比如第一次在github上完成项目，第一次通过这种完全线上的方式和队友合作，这对我来说都是宝贵的经验，我觉得只要我在这个过程中有所成长，那么这次课设对我来说就是很有意义的。最后也要感谢编译原理全体老师的辛勤付出和学长学姐们的悉心指导，让我能有这样一次锻炼自己，开拓眼界的机会。我相信，在接下来的日子里，这段时光也一定会成为我难忘的回忆。
